<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>monet</title>

    <link rel="icon" type="image/png" href="assets/favicon/monet/android-chrome-192x192.png">
    <link rel="icon" type="image/x-icon" href="assets/favicon/monet/favicon.ico">
    <link rel="icon" sizes="32x32" href="assets/favicon/monet/favicon-32x32.png">
    <link rel="icon" sizes="16x16" href="assets/favicon/monet/favicon-16x16.png">
    <link rel="manifest" href="assets/favicon/monet/manifest.json">


    <style>

        :root {
            --primary-color: #ff8222; /* Example primary color */
            --secondary-color: #fdfeff; /* Example secondary color */
            --accent-color: #2b2b2b; /* Example accent color */
            --background-color: #e0e0e0; /* Example background color */
            --text: #2b2b2b;
            --shadow: rgba(186, 186, 186, 0.5);
        }

        body{
            margin: 0;
            display: inline-block;
            overflow: hidden; /* hide scrollbars */
        }

        #paint_canvas {
            background-color: var(--secondary-color);
            image-rendering: pixelated;

            position: absolute;
            left: 40000px;
            top: 40000px;

            /* border: 1px solid white; */
            background-color: rgba(255, 255, 255, 0);     
            box-shadow: 0px 0px 10px 0 var(--shadow);       
        }

        #paint-background {
            background-color: #e0e0e0;
            height: 80000px;
            width: 80000px;
            z-index: 0;

        }

        .menu{
            position: fixed;
            height: 100%;
            z-index: 1;
            background-color: var(--secondary-color);
            box-shadow: 0px 0px 10px 0 var(--shadow);
            /* background-color: #585858; */
        }

        .menu_button {
            padding: .5rem;
        }

        .sub_menu {
            display: none;
            position: fixed;
            background-color: var(--secondary-color);
            padding: 8px;
            z-index: 10; /* Make sure it appears above other content */
            border-radius: 4px;

            flex-direction: column;
            box-shadow: 0px 0px 10px 0 var(--shadow);
        }


        #color_icon {
            width: 20 rem;
            height: 3rem;
            background-color: var(--primary-color);
            box-shadow: 0px 0px 10px 0 var(--shadow);
            margin: .3rem;
        }

        #color_choice {
            display: flex;
            flex-direction: column;
        }

        .menu_text {
            color: var(--accent-color);
        }

        .color-picker {
            text-align: center;
        }

        .slider {

            box-shadow: 0px 0px 10px 0 var(--shadow);
            margin: .3rem;
        }

        .slider::-webkit-slider-thumb, .slider::-moz-range-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px; 
            height: 20px; 
            background: white; 
            border: 2px solid #ccc; 
            border-radius: 50%;
            cursor: pointer;
        }

        #hue_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 20rem;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(0, 100%, 50%),
                hsl(30, 100%, 50%),
                hsl(60, 100%, 50%),
                hsl(90, 100%, 50%),
                hsl(120, 100%, 50%),
                hsl(150, 100%, 50%),
                hsl(180, 100%, 50%),
                hsl(210, 100%, 50%),
                hsl(240, 100%, 50%),
                hsl(270, 100%, 50%),
                hsl(300, 100%, 50%),
                hsl(330, 100%, 50%)
            );
            border-radius: 15px;
            outline: none;
        }

        #saturation_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 20 rem;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(30, 0%, 50%),
                hsl(30, 50%, 50%),
                hsl(30, 100%, 50%)
            );
            border-radius: 10px;
            outline: none;
        }

        #lightness_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 20 rem;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(30, 100%, 0%),
                hsl(30, 100%, 10%),
                hsl(30, 100%, 20%),
                hsl(30, 100%, 30%),
                hsl(30, 100%, 40%),
                hsl(30, 100%, 50%),
                hsl(30, 100%, 60%),
                hsl(30, 100%, 70%),
                hsl(30, 100%, 80%),
                hsl(30, 100%, 90%),
                hsl(30, 100%, 100%)
            );
            border-radius: 15px;
            outline: none;
        }

        #alpha_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 20 rem;
            height: 20px;
            background: linear-gradient(to right, 
                hsl(30, 100%, 50%, 0%),
                hsl(30, 100%, 50%, 10%),
                hsl(30, 100%, 50%, 20%),
                hsl(30, 100%, 50%, 30%),
                hsl(30, 100%, 50%, 40%),
                hsl(30, 100%, 50%, 50%),
                hsl(30, 100%, 50%, 60%),
                hsl(30, 100%, 50%, 70%),
                hsl(30, 100%, 50%, 80%),
                hsl(30, 100%, 50%, 90%),
                hsl(30, 100%, 50%, 100%)
            );
            border-radius: 15px;
            outline: none;
        }

        #alpha_back {
            background-color: var(--background-color);
            width: 20 rem;
            height: 20px;
            border-radius: 15px;
            outline: none;
        }

        .color_value_text {
            color: var(--text);
            border: 1px solid var(--accent-color); 
            border-radius: 3px;
            font-size: 1rem;
            text-align: center;
        }

        .color_format_label {
            color: var(--text);
        }

        #color_format_grid {
            display: grid;
            grid-template-columns: .1fr 1fr;
            grid-gap: .3rem;
            margin: .3rem;
        }

        #color_format_grid > * {
            padding: .5rem;
        }

        #move_button {
            height: 3rem;
            width: 3rem;

            display: flex;
            justify-content: center;
            align-items: center;
        }

        #erase_button {
            height: 3rem;
            width: 3rem;

            display: flex;
            justify-content: center;
            align-items: center;
        }


        .tooltip-text {
            visibility: hidden;
            background-color: var(--secondary-color);
            box-shadow: 0px 0px 10px 0 var(--shadow);
            color: var(--text);
            text-align: center;
            border-radius: 5px;
            padding: 5px;
            position: fixed;
            z-index: 400;
            opacity: 0; /* Initially hidden */
            transition: opacity 0.3s;
            font-size: 1.2rem;
        }

        .menu_button:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }


        #draw_size_grid {
            display: grid;
            grid-template-columns: 1fr;
        }

        #draw_size_label {
            margin: .3rem;
            padding: 0.5rem;
        }

        #draw_size_slider {
            -webkit-appearance: none; /* Remove default styling for WebKit browsers */
            appearance: none; /* Remove default styling for other browsers */
            width: 20 rem;
            height: 10px;
            background: var(--secondary-color);
            border-radius: 15px;
            outline: none;
        }

        #draw_size_circle {
            margin: .8rem;
            background-color: var(--primary-color);
            width: 10px;
            height: 10px;
            border-radius: 10px;
            box-shadow: 0px 0px 10px 0 var(--shadow);
        }

        #download_button {
            height: 3rem;
            width: 3rem;

            display: flex;
            justify-content: center;
            align-items: center;
        }

        #download_button:hover {

            background-color: #f6f6f6;

        }

        #settings_button {
            height: 3rem;
            width: 3rem;

            display: flex;
            justify-content: center;
            align-items: center;
        }

        #settings_button:hover {

            background-color: #f6f6f6;

        }

        .canvas_title {
            font-size: 1.3rem;
        }

        #canvas_size_grid {
            display: grid;
            grid-template-columns: .3fr 1fr .3fr 1fr;
            gap: .5rem;
            margin: .3rem;
        }

        .canvas_size_text {
            padding: .5rem;
        }

        .canvas_size_value {
            color: var(--text);
            border: 1px solid var(--accent-color); 
            border-radius: 3px;
            font-size: .8rem;
            text-align: center;
            margin: .3rem;
            width: 3rem;
        }

        #image_background_input {
            margin: 1rem;
        }
        
        #background_color_grid {
            display: grid;
            grid-template-columns: .5fr 1fr;
            margin: 1rem;
        }
        
        #background_color_view {
            width: 3rem;
            height: 3rem;
            background-color: var(--primary-color);
            box-shadow: 0px 0px 10px 0 var(--shadow);
        }

        #background_color_input {

            color: var(--text);
            border: 1px solid var(--accent-color); 
            border-radius: 3px;
            font-size: .8rem;
            text-align: center;
            margin: .3rem;
        }

        #select_box {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.039);   
            z-index: 100;

            /* left: 300px;
            top: 300px;
            width: 300px;
            height: 300px; */
        }


        #color_wheel_sub_menu {
            position: fixed;
            /* display: block; */
            display: none;
        }

        #color_wheel {
            --radius: 32rem;
            --neg_half_rad: -16rem;
            position: absolute;

            left: var(--neg_half_rad);
            top: var(--neg_half_rad);

            width: var(--radius);
            height: var(--radius);
            border-radius: 50%;
            /* background-color: #3498db; */
        }
        
        .color_stick {
            position: absolute;
            /* To make sure the squares are centered on their positions: */
            transform-origin: center;

        }

        .color_square {
            width: 2rem;
            height: 2rem;
            background-color: #e67e22;
            margin: 1rem;

        }

        #color_picker_section {
            width: 100%;
            display: flex;
            justify-content: end;
        }

        #color_picker {
            padding: 0.5rem;
            border-radius: 10px;

            display: flex;
            justify-content: center;
            align-items: center;
        }

        #download_popup {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.166);
            top: 0;
            left: 0;
            z-index: 1000;
            width: 100%;
            height: 100%;
            display: none;
        }

        #download_popup_div {
            position: fixed;
            background-color: white;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 1rem;
            border-radius: 10px;   
            box-shadow: 0px 0px 10px 0 var(--shadow);   
        }

        #download_submit_button {
            border: 0;
            border-radius: 10px;
            padding: .5rem 1rem .5rem 1rem;
        }
    </style>
</head>
<body>
    
    <!-- draw sub menu -->
    <div 
        id='draw_button_sub_menu'
        class="sub_menu"
    >
        <div id='color_choice'>
            <div id='color_icon'></div>
            <div id="color_format_grid">
                <span class="color_format_label">HEX</span>
                <input type="text" id='hex_value_text' class="color_value_text" value="">
                <span class="color_format_label">HSL</span>
                <input type="text" id='hsl_value_text' class="color_value_text" value="">
                <span class="color_format_label">RGBA</span>
                <input type="text" id='rgba_value_text'class="color_value_text" value="">
            </div>
            <input type="range" id="hue_slider" class='slider' min="0" max="330" value="0">
            <input type="range" id="saturation_slider" class='slider' min="0" max="100" value="0">
            <input type="range" id="lightness_slider" class='slider' min="0" max="100" value="0">
            <input type="range" id="alpha_slider" class='slider' min="0" max="100" value="0">
            
            <div id="draw_size_grid">
                <span id="draw_size_label">BRUSH SIZE</span>
                <input type="range" id="draw_size_slider" class='slider' min="1" max="100a" value="10">
                <div>
                    <div id="draw_size_circle"></div>
                </div>
            </div>
            <div id="color_picker_section">
                <div
                    id="color_picker"
                    onclick="color_picker_click()"
                >
                    <svg 
                        id="color_picker_svg"
                        xmlns="http://www.w3.org/2000/svg" 
                        width="1rem" 
                        height="1rem" 
                        fill="var(--accent-color)" 
                        stroke="var(--accent-color)" 
                        class="bi bi-eyedropper" 
                        viewBox="0 0 16 16"
                    >
                        <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708zM2 12.707l7-7L10.293 7l-7 7H2z"/>
                    </svg>
                </div>
            </div>
        </div>
    </div>

    <!-- draw wheel picker -->
    <div id='color_wheel_sub_menu'>
        <div id ='color_wheel'>
            <div class='color_stick'>
                <div class='color_square' style="background-color: #5b5b5b;"></div>
                <div class='color_square' style="background-color: #2b2b2b;"></div>
                <div class='color_square' style="background-color: #202020;"></div>
                <div class='color_square' style="background-color: #000000;"></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
            <div class='color_stick'>
                <div class='color_square'></div>
            </div>
        </div>
        
    </div>

    <!-- side menu -->
    <div class='menu'>
        <div
            id="draw_button"
            class="menu_button"
            onclick="draw_button_click()"
        >
            <svg
                id="draw-svg"
                xmlns="http://www.w3.org/2000/svg"
                width="3rem"
                height="3rem"
                viewBox="0 0 24 24"
                fill="var(--accent-color)"
                stroke="var(--accent-color)"
                stroke-width="1"
                stroke-linecap="round"
                stroke-linejoin="round"
            >
                <polygon points="7 5  17 15  18 18  15 17  5 7" />
            </svg>
            <span id="draw_tool_tip" class="tooltip-text">a</span>
        
        </div>

        <div
            id="move_button"
            class="menu_button"
            onclick="move_mode_button_click()"
        >
            <svg 
                id="move_svg" 
                xmlns="http://www.w3.org/2000/svg" 
                width="2rem" 
                height="2rem" 
                fill="var(--accent-color)" 
                stroke="var(--accent-color)" 
                class="bi bi-hand-index-fill" 
                viewBox="0 0 16 16"
            >
                <!-- <path d="M8.5 1.75v2.716l.047-.002c.312-.012.742-.016 1.051.046.28.056.543.18.738.288.273.152.456.385.56.642l.132-.012c.312-.024.794-.038 1.158.108.37.148.689.487.88.716q.113.137.195.248h.582a2 2 0 0 1 1.99 2.199l-.272 2.715a3.5 3.5 0 0 1-.444 1.389l-1.395 2.441A1.5 1.5 0 0 1 12.42 16H6.118a1.5 1.5 0 0 1-1.342-.83l-1.215-2.43L1.07 8.589a1.517 1.517 0 0 1 2.373-1.852L5 8.293V1.75a1.75 1.75 0 0 1 3.5 0"/> -->
                <path d="M8.5 4.466V1.75a1.75 1.75 0 1 0-3.5 0v5.34l-1.2.24a1.5 1.5 0 0 0-1.196 1.636l.345 3.106a2.5 2.5 0 0 0 .405 1.11l1.433 2.15A1.5 1.5 0 0 0 6.035 16h6.385a1.5 1.5 0 0 0 1.302-.756l1.395-2.441a3.5 3.5 0 0 0 .444-1.389l.271-2.715a2 2 0 0 0-1.99-2.199h-.581a5 5 0 0 0-.195-.248c-.191-.229-.51-.568-.88-.716-.364-.146-.846-.132-1.158-.108l-.132.012a1.26 1.26 0 0 0-.56-.642 2.6 2.6 0 0 0-.738-.288c-.31-.062-.739-.058-1.05-.046z"/>
            </svg>
            <!-- <svg
                id="move_svg" 
                xmlns="http://www.w3.org/2000/svg" 
                width="2rem" 
                height="2rem" 
                fill="var(--accent-color)" 
                stroke="var(--accent-color)" 
                class="bi bi-arrows-move" 
                viewBox="0 0 16 16"
            >
                <path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 1.707V5.5a.5.5 0 0 1-1 0V1.707L6.354 2.854a.5.5 0 1 1-.708-.708zM8 10a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 0 1 .708-.708L7.5 14.293V10.5A.5.5 0 0 1 8 10M.146 8.354a.5.5 0 0 1 0-.708l2-2a.5.5 0 1 1 .708.708L1.707 7.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 0 1-.708.708zM10 8a.5.5 0 0 1 .5-.5h3.793l-1.147-1.146a.5.5 0 0 1 .708-.708l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L14.293 8.5H10.5A.5.5 0 0 1 10 8"/>
            </svg> -->
            <span id="move_tool_tip" class="tooltip-text">s</span>
        </div>

        <div
            id="erase_button"
            class="menu_button"
            onclick="erase_button_click()"
        >
            <svg 
                id="erase_svg" 
                xmlns="http://www.w3.org/2000/svg" 
                width="2rem" 
                height="2rem" 
                fill="var(--accent-color)" 
                stroke="var(--accent-color)" 
                class="bi bi-eraser-fill" 
                viewBox="0 0 16 16"
            >
                <path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828zm.66 11.34L3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293z"/>
            </svg>
            <span id="erase_tool_tip" class="tooltip-text">d</span>
        </div>

        <div
            id="download_button"
            class="menu_button"
            onclick="download_dialog()"
        >
            
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width="2rem" 
                height="2rem" 
                fill="var(--accent-color)" 
                stroke="var(--accent-color)" 
                class="bi bi-download" 
                viewBox="0 0 16 16"
            >
                <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/>
                <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/>
            </svg>
            <span id="download_tool_tip" class="tooltip-text">f</span>
        </div>

        <div
            id="settings_button"
            class="menu_button"
            onclick="settings_button_click()"
        >
            <svg 
                id="settings_svg" 
                xmlns="http://www.w3.org/2000/svg" 
                width="2rem" 
                height="2rem" 
                fill="var(--accent-color)" 
                stroke="var(--accent-color)" 
                class="bi bi-gear-fill" 
                viewBox="0 0 16 16"
            >
                <path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/>
            </svg>
            <span id="settings_tool_tip" class="tooltip-text">g</span>
        </div>

       

    </div>

    <!-- background and canvas -->
    <div id="paint-background">
        <!-- <div id="select_box"></div> -->
        <canvas id="paint_canvas"></canvas>
    </div>

    <!-- settings sub menu -->
    <div 
        id='settings_sub_menu'
        class="sub_menu"
    >
        <span class="canvas_title">Canvas Size</span>
        <div id="canvas_size_grid">
            <span class="canvas_size_text">width</span>
            <input type="text" id='canvas_width_input' class="canvas_size_value" value="">
            <span class="canvas_size_text">height</span>
            <input type="text" id='canvas_height_input' class="canvas_size_value" value="">
        </div>

        <span class="canvas_title">Background</span>

        <input type="file" id="image_background_input" accept="image/*">

        <div id="background_color_grid">
            <div id="background_color_view"></div>
            <input type="text" id='background_color_input' value="#ffff8324">
        </div>
        
    </div>



    <div id="download_popup">
        <div id="download_popup_div">
            <p>file name</p>
            <input id="file_name_input" type="text">
            <button id="download_submit_button" onclick="download_image()">Download</button>
        </div>
    </div>




    <!-- ******* -->
    <!-- SCRIPTS -->
    <!-- ******* -->


    <!-- UTIL -->
    <script>

        // CRYPTO RANDOM
        function random_crypto(min, max) {
            // Create a Uint32Array to hold the random value
            const randomBuffer = new Uint32Array(1);
            
            // Fill the array with random values
            window.crypto.getRandomValues(randomBuffer);
            
            // Scale the random value to the desired range and convert to float
            return (randomBuffer[0] / (0xFFFFFFFF + 1)) * (max - min) + min;
        }

        // UUID
        function uuidV4() {
            const uuid = new Array(36);
            for (let i = 0; i < 36; i++) {
                uuid[i] = Math.floor(random_crypto(0, 16));
            }
            uuid[14] = 4; // set bits 12-15 of time-high-and-version to 0100
            uuid[19] = uuid[19] &= ~(1 << 2); // set bit 6 of clock-seq-and-reserved to zero
            uuid[19] = uuid[19] |= (1 << 3); // set bit 7 of clock-seq-and-reserved to one
            uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
            return uuid.map((x) => x.toString(16)).join('');
        }

        // COLOR CODE CONVERSIONS
        function hsla_to_rgba(h, s, l, a) {
            // Normalize hue to [0, 360]
            h = h % 360;
            // Normalize saturation and lightness to [0, 1]
            s /= 100.0;
            l /= 100.0;

            let r, g, b;

            if (s === 0) {
                // Achromatic (gray)
                r = g = b = l * 255;
            } else {
                const c = (1 - Math.abs(2 * l - 1)) * s; // Chroma
                const x = c * (1 - Math.abs((h / 60) % 2 - 1)); // Secondary component
                const m = l - c / 2; // Match lightness

                // Determine RGB values based on hue
                if (h >= 0 && h < 60) {
                    r = c; g = x; b = 0;
                } else if (h >= 60 && h < 120) {
                    r = x; g = c; b = 0;
                } else if (h >= 120 && h < 180) {
                    r = 0; g = c; b = x;
                } else if (h >= 180 && h < 240) {
                    r = 0; g = x; b = c;
                } else if (h >= 240 && h < 300) {
                    r = x; g = 0; b = c;
                } else {
                    r = c; g = 0; b = x;
                }

                // Adjust for lightness
                r = Math.round((r + m) * 255);
                g = Math.round((g + m) * 255);
                b = Math.round((b + m) * 255);
            }

            // Return RGBA values
            return {
                r: r,
                g: g,
                b: b,
                a: Math.round(a * 2.55) 
            };
        }

        function rgba_to_hsla(r, g, b, a) {
            // Convert RGB values from 0-255 to 0-1
            r /= 255.0;
            g /= 255.0;
            b /= 255.0;
            a /= 255.0;
            a *= 100.0;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l;

            // Compute lightness
            l = (max + min) / 2;

            if (max === min) {
                // Achromatic case (gray)
                h = 0;
                s = 0;
            } else {
                const delta = max - min;

                // Saturation
                s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);

                // Hue
                switch (max) {
                case r:
                    h = ((g - b) / delta + (g < b ? 6 : 0));
                    break;
                case g:
                    h = ((b - r) / delta + 2);
                    break;
                case b:
                    h = ((r - g) / delta + 4);
                    break;
                }

                h /= 6; // Convert to range 0-1
            }

            // Convert hue to degrees, saturation and lightness to percentages
            return {
                hue: Math.round(h * 360),
                saturation: Math.round(s * 100),
                lightness: Math.round(l * 100),
                alpha: a
            };
        }

        function rgba_to_hex(r, g, b, a) {

            // Ensure R, G, B are in the range [0, 255]
            r = Math.min(255, Math.max(0, Math.round(r)));
            g = Math.min(255, Math.max(0, Math.round(g)));
            b = Math.min(255, Math.max(0, Math.round(b)));
            

            if (a == 255) {
                // Convert R, G, B, and A to hex and pad with zeros
                const hex = (r << 16 | g << 8 | b) >>> 0; // Ensure unsigned
                return `#${('000000' + hex.toString(16)).slice(-6)}`; // Format as 8-digit hex
            }
            else {
                // Convert R, G, B, and A to hex and pad with zeros
                const hex = (r << 16 | g << 8 | b | (a << 24)) >>> 0; // Ensure unsigned
                return `#${('00000000' + hex.toString(16)).slice(-8)}`; // Format as 8-digit hex
            }
            
        }

        // #f524fff0
        // 36, 255, 240
        function hex_to_rgba(hex) {
            // Remove the hash at the start if it's there
            hex = hex.replace(/^#/, '');

            let r, g, b, a = 255; // Default alpha to 1 (fully opaque)

            // Check if the hex code is 8 characters (with alpha)
            if (hex.length === 8) {
                a = parseInt(hex.substring(0, 2), 16);
                r = parseInt(hex.substring(2, 4), 16);
                g = parseInt(hex.substring(4, 6), 16);
                b = parseInt(hex.substring(6, 8), 16);
            } 
            // Check if the hex code is 6 characters (without alpha)
            else if (hex.length === 6) {
                r = parseInt(hex.substring(0, 2), 16);
                g = parseInt(hex.substring(2, 4), 16);
                b = parseInt(hex.substring(4, 6), 16);
            } 
            // Invalid hex code
            else {
                throw new Error('Invalid hex code');
            }

            return {
                r: r,
                g: g,
                b: b,
                a: a
            };
        }

    </script>

    <!-- GENERAL VARAIBLES -->
    <script>
        let draw_mode = false;
        let move_mode = false;
        let erase_mode = false;
        let in_settings = false;

        let drawing = false;
        let typing = false;
        let color_pick = false;
        let draw_box_select = false;
        let move_box_select = false;
        let dims = { defaultWidth: 1920, defaultHeight: 1080 };
        let width = 0;
        let height = 0;
        const canvas = document.getElementById('paint_canvas');
        let select_box = document.getElementById("select_box");
        let ctx = canvas.getContext('2d');
        let drag_x, drag_y;
        let color = {
            hue: 26,
            saturation: 100,
            lightness: 57,
            alpha: 100
        };
        let brush_radius = 10;
        
    </script>

    <!-- LAYERS AND CANVAS RENDERING -->
    <script>
        let layers = new Map();
        let uuid_to_stroke = new Map(); // uuid to stoke with pixel data
        let pixel_x_y_to_strokes = new Map();
        let current_layer = uuidV4();

        let canvas_background_img = null;
        let canvas_background_color = {
            r: 255,
            g: 255,
            b: 255,
            a: 255
        };

        
        function draw_canvas_background() {
            if (canvas.width > 0 && canvas.height > 0) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                for (let x = 0; x < canvas.width; x++) {
                    for (let y = 0; y < canvas.height; y++) {
                        const index = Math.round(y * canvas.width + x) * 4; // Calculate index for the pixel
                        imageData.data[index] = canvas_background_color.r;     // Red
                        imageData.data[index + 1] = canvas_background_color.g;   // Green
                        imageData.data[index + 2] = canvas_background_color.b;   // Blue
                        imageData.data[index + 3] = canvas_background_color.a; // Alpha
                    }
                }
                ctx.putImageData(imageData, 0, 0);

                if (canvas_background_img != null) {
                    set_pixels(canvas_background_img);
                }

            }
        }

        function re_draw() {

            const start = performance.now();
            draw_canvas_background();
            for (const [layer_uuid, layer] of layers.entries()) {
                for (let stroke_uuid of layer.strokes) {
                    set_pixels(uuid_to_stroke.get(stroke_uuid).pixels);
                }
            }
            // console.log("completed re-draw", performance.now() - start, "ms");
            // console.log("layers", layers);
        }

        function mouse_x_to_canvas_x(x) {
            const canvas_width = parseFloat(canvas.style.width);
            const zoom_factor = canvas_width / dims.defaultWidth;
            x = x + window.scrollX - CANVAS_X;
            return Math.floor(x / zoom_factor);
        }

        function mouse_y_to_canvas_y(y) {
            const canvas_width = parseFloat(canvas.style.width);
            const zoom_factor = canvas_width / dims.defaultWidth;
            y = y + window.scrollY - CANVAS_Y;
            return Math.floor(y / zoom_factor);
        }
    


        // DRAWING STROKES
        let stroke_uuid = uuidV4();
        let stroke_path_checker = new Set();
        let pixel_checker = new Set();
        let count = 0;
        let stroke = {
            layer_uuid: current_layer,
            uuid: stroke_uuid,
            pixels: [],
            order: count
        };
        function finish_stroke(new_action) {

            if (layers.has(current_layer)) {
                layers.get(current_layer).strokes.push(stroke_uuid);
            }
            else {
                layers.set(
                    current_layer, 
                    {
                        strokes: [stroke_uuid]
                    }
                );
            }


            stroke.layer_uuid = current_layer;
            stroke.uuid = stroke_uuid;
            stroke.order = count;
            count++;
            uuid_to_stroke.set(stroke_uuid, stroke);

            // console.log("new stroke", stroke_uuid);
            if (new_action) add_action(ADD_STROKE, stroke);

            // reset temp vars
            stroke_uuid = uuidV4();
            stroke = {
                layer_uuid: current_layer,
                uuid: stroke_uuid,
                pixels: [],
                order: count
            };
            stroke_path_checker.clear();
            pixel_checker.clear();


        }

        function add_to_stroke(pixels, apply_radius) {

            // console.log("pixels before", pixels);

            // remove any duplicates
            pixels = pixels.filter(pixel => {
                const tag = `${pixel.x}_${pixel.y}`;
                if (!stroke_path_checker.has(tag)) {
                    stroke_path_checker.add(tag);
                    return true;
                }
                else {
                    return false;
                }
            });
            

            // add stroke radius
            // console.log("brush_radius", brush_radius);
            // console.log("pixels", pixels);
            if (apply_radius) {
                let brush_pixels = [];
                const half_radius = Math.floor(brush_radius / 2);
                for (let x = -half_radius; x < half_radius; x++) {
                    for (let y = -half_radius; y < half_radius; y++) {

                        let dist = Math.sqrt(
                            Math.pow(x, 2) +
                            Math.pow(y, 2)
                        );
                        if (dist < half_radius) {
                            brush_pixels.push({
                                x: x,
                                y: y
                            });
                        }
                        
                    }
                }
                pixels = pixels.flatMap(pixel => {
                    const start_x = pixel.x - brush_radius;
                    const end_x = pixel.x + brush_radius;
                    const start_y = pixel.y - brush_radius;
                    const end_y = pixel.y + brush_radius;

                    let radius_pixels = [];
                    let tag = `${pixel.x}_${pixel.y}`;
                    if (!pixel_checker.has(tag)) {
                        radius_pixels.push(pixel);
                    }
                    for (const brush_pixel of brush_pixels) {
                        const x = pixel.x + brush_pixel.x;
                        const y = pixel.y + brush_pixel.y;
                        tag = `${x}_${y}`;
                        if (!pixel_checker.has(tag) && !stroke_path_checker.has(tag)) {
                            pixel_checker.add(tag);
                            radius_pixels.push({
                                x: x,
                                y: y,
                                r: pixel.r,
                                g: pixel.g,
                                b: pixel.b,
                                a: pixel.a
                            });
                        }
                    }

                    return radius_pixels;
                });
            }
            // console.log("pixels", pixels);


            for (const pixel of pixels) {
                stroke.pixels.push(pixel);
            }
            
            add_stroke(pixels);
        }

        function add_stroke(pixels) {
            pixels.forEach(pixel => {
                const tag = `${pixel.x}_${pixel.y}`;
                if (pixel_x_y_to_strokes.has(tag)) {
                    pixel_x_y_to_strokes.get(tag).push(stroke_uuid);
                }
                else {
                    pixel_x_y_to_strokes.set(tag, [stroke_uuid]);
                }
            });
            set_pixels(pixels);
        }


        /*
            pixels is an array of pixel objects with an x, y, and rgba color value
        */
        function set_pixels(pixels) {
            // console.log("set_pixels");

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            // console.log("pixels", pixels);

            pixels.forEach((pixel) => {

                if (pixel.x < canvas.width && pixel.y < canvas.height && pixel.x >= 0 && pixel.y >= 0) {
                    const index = Math.round(pixel.y * canvas.width + pixel.x) * 4; // Calculate index for the pixel

                    // Set the alpha composite pixel color (R, G, B, A)
                    const r_image = imageData.data[index];
                    const g_image = imageData.data[index + 1];
                    const b_image = imageData.data[index + 2];
                    const a_image = imageData.data[index + 3] / 255;

                    const r_new = pixel.r;
                    const g_new = pixel.g;
                    const b_new = pixel.b;
                    const a_new = pixel.a / 255;

                    // alpha composite
                    const result_color = alpha_composite(r_image, g_image, b_image, a_image, r_new, g_new, b_new, a_new);

                    // set the resulting color
                    imageData.data[index] = result_color.r;     // Red
                    imageData.data[index + 1] = result_color.g;   // Green
                    imageData.data[index + 2] = result_color.b;   // Blue
                    imageData.data[index + 3] = result_color.a * 255; // Alpha

                }
            });
            ctx.putImageData(imageData, 0, 0);
        }

        
        function remove_stroke(stroke_uuid) {

            const storke_to_remove = uuid_to_stroke.get(stroke_uuid);

            // remove from map
            uuid_to_stroke.delete(stroke_uuid);

            // remove from xy map
            storke_to_remove.pixels.forEach(pixel => {
                const tag = `${pixel.x}_${pixel.y}`;
                pixel_x_y_to_strokes.set(
                    tag, 
                    pixel_x_y_to_strokes.get(tag).filter(uuid => uuid !== stroke_uuid)
                );
            });

            // remove from layer
            current_layer = storke_to_remove.layer_uuid;
            layers.get(current_layer).strokes.filter(uuid => uuid != stroke_uuid);


            // set pixels on canvas
            console.log("canvas_background_img", canvas_background_img);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            storke_to_remove.pixels.forEach((pixel) => {

                if (pixel.x < canvas.width && pixel.y < canvas.height && pixel.x >= 0 && pixel.y >= 0) {
                    const index = Math.round(pixel.y * canvas.width + pixel.x) * 4; // Calculate index for the pixel

                    let r_image = 0;
                    let g_image = 0;
                    let b_image = 0;
                    let a_image = 0;
                    const background_index = pixel.y * canvas.width + pixel.x;
                    if (canvas_background_img && background_index < canvas_background_img.length) {
                        const background_pixel = canvas_background_img[background_index];
                        r_image = background_pixel.r;
                        g_image = background_pixel.g;
                        b_image = background_pixel.b;
                        a_image = background_pixel.a / 255;
                        // console.log(r_image, g_image, b_image, a_image);
                    }
                    else {
                        r_image = canvas_background_color.r;
                        g_image = canvas_background_color.g;
                        b_image = canvas_background_color.b;
                        a_image = canvas_background_color.a / 255;
                    }

                    // iterate over strokes we're keeping and set pixels
                    const tag = `${pixel.x}_${pixel.y}`;
                    const keep_stroke_uuids = pixel_x_y_to_strokes.get(tag);
                    for (const uuid of keep_stroke_uuids) {
                        const keep_stroke = uuid_to_stroke.get(uuid);
                        const first_pixel = keep_stroke.pixels[0];

                        const r_new = first_pixel.r;
                        const g_new = first_pixel.g;
                        const b_new = first_pixel.b;
                        const a_new = first_pixel.a / 255;

                        const result_color = alpha_composite(r_image, g_image, b_image, a_image, r_new, g_new, b_new, a_new);
                        r_image = result_color.r;
                        g_image = result_color.g;
                        b_image = result_color.b;
                        a_image = result_color.a;
                    }


                    // set the resulting color
                    imageData.data[index] = r_image;     // Red
                    imageData.data[index + 1] = g_image;   // Green
                    imageData.data[index + 2] = b_image;   // Blue
                    imageData.data[index + 3] = a_image * 255; // Alpha

                }
            });
            ctx.putImageData(imageData, 0, 0);
        }

        /*
            Combines to color with transparency. 

            rgb values are 0-255 and alpha values are 0.0-1.0
        */
        function alpha_composite(r_background, g_backround, b_background, a_background, r_new, g_new, b_new, a_new) {
            
            // Calculate the resulting alpha
            const a_r = a_new + (a_background * (1 - a_new));

            const r_r = (r_new * a_new + r_background * a_background * (1 - a_new)) / a_r;
            const g_r = (g_new * a_new + g_backround * a_background * (1 - a_new)) / a_r;
            const b_r = (b_new * a_new + b_background * a_background * (1 - a_new)) / a_r;


            return {
                r: r_r,
                g: g_r,
                b: b_r,
                a: a_r
            };
        }


        // MOVING STROKES
        let canvas_data_without_selected_strokes = null;
        let selected_stroke_uuids = null;
        let selected_strokes = null;
        let delta_x_sum = 0;
        let delta_y_sum = 0;
        function save_canvas_and_get_selected_strokes(xy_coordinates) {

            // console.log("save_canvas_and_get_selected_strokes ");
            // console.log("uuid_to_stroke", uuid_to_stroke);

            // get selected stroke
            
            selected_stroke_uuids = new Set();
            for (const coordinate of xy_coordinates) {
                let x = coordinate.x;
                let y = coordinate.y;
                const tag = `${x}_${y}`;
                let strokes_at_coor = pixel_x_y_to_strokes.get(tag);

                if (strokes_at_coor) {
                    // console.log("strokes_at_coor", strokes_at_coor);
                    for (const stroke_uuid of strokes_at_coor) {
                        selected_stroke_uuids.add(stroke_uuid);
                    }
                }
            }


            // console.log("selected_stroke_uuids", selected_stroke_uuids);
            // console.log("selected_stroke_uuids.size", selected_stroke_uuids.size);
            if (selected_stroke_uuids && selected_stroke_uuids.size > 0) {


                selected_strokes = Array.from(selected_stroke_uuids).map(uuid => {
                    let stroke = uuid_to_stroke.get(uuid);
                    return stroke;
                }).sort((a, b) => {
                    // sorting by added order
                    return a.order - b.order;
                });;
                // console.log("selected_strokes", selected_strokes);

                if (selected_strokes) {
                    add_action(MOVE_STROKES, selected_strokes);

                    selected_stroke_uuids.forEach(uuid => {
                        remove_stroke(uuid);
                    });

                    // save canvas
                    canvas_data_without_selected_strokes = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    selected_strokes.forEach(selected_stroke => {
                        set_pixels(selected_stroke.pixels);
                    });


                    return selected_stroke_uuids;
                }


            }
            else {
                selected_stroke_uuids == null;
            }

            return null;
        }
    
        function update_selected_stroke(clientX, clientY) {
            // console.log("update_selected_stroke");
            // console.log("selected_stroke_uuid", selected_stroke_uuid);

            if (selected_strokes) {
                
                // update stroke pixels
                const canvas_width = parseFloat(canvas.style.width);
                const zoom_factor = canvas_width / dims.defaultWidth;
                // console.log("zoom_factor", zoom_factor);
                delta_x_sum += (clientX - drag_x) / zoom_factor;
                delta_y_sum += (clientY - drag_y) / zoom_factor;
                let delta_x = Math.floor(delta_x_sum);
                let delta_y = Math.floor(delta_y_sum);
                delta_x_sum -= delta_x;
                delta_y_sum -= delta_y;
                // console.log('delta_x', delta_x);
                // console.log('delta_y', delta_y);
                // console.log('selected_strokes', selected_strokes);

                selected_strokes.forEach(selected_stroke => {
                    selected_stroke.pixels = selected_stroke.pixels.map(pixel => {
                        pixel.x += delta_x;
                        pixel.y += delta_y;

                        return pixel;
                    });
                });

                // draw saved canvas
                ctx.putImageData(canvas_data_without_selected_strokes, 0, 0);

                // draw selected strokes
                selected_strokes.forEach(selected_stroke => {
                    set_pixels(selected_stroke.pixels);
                });

            }
        }

        function drop_selected_stroke() {
            // console.log("drop_selected_stroke");
            
            if (selected_strokes) {

                // draw saved canvas
                ctx.putImageData(canvas_data_without_selected_strokes, 0, 0);

                // re-add strokes
                selected_strokes.sort((a, b) => {
                    // sorting by added order
                    return a.order - b.order;
                }).forEach(selected_stroke => {
                    uuid_to_stroke.delete(selected_stroke.uuid);
                    stroke_uuid = selected_stroke.uuid;
                    add_to_stroke(selected_stroke.pixels, false);
                    finish_stroke(false);
                });

                // draw stroke
                // set_pixels(selected_stroke.pixels);

                // reset temp varaibles
                canvas_data_without_selected_strokes = null;
                selected_stroke_uuids = null;
                selected_strokes = null;
                delta_x_sum = 0;
                delta_y_sum = 0;
                // console.log("reset");

            }

            // console.log('uuid_to_stroke', uuid_to_stroke);
        }
    
        function get_most_recent_stroke_at_xy(clientX, clientY) {

            // get stroke at click point
            let x = mouse_x_to_canvas_x(clientX);
            let y = mouse_y_to_canvas_y(clientY);
            const tag = `${x}_${y}`;
            let strokes_at_coor = pixel_x_y_to_strokes.get(tag);

            // get the stroke placed most recently (XXX: repect layers here)
            if (strokes_at_coor && strokes_at_coor.length > 0) {
                let most_recent;
                let most_recent_order = -1;
                strokes_at_coor.forEach(uuid => {
                    let stroke = uuid_to_stroke.get(uuid);
                    if (stroke.order > most_recent_order) {
                        most_recent = stroke;
                        most_recent_order = stroke.order;
                    }
                });
                return most_recent;
            }
            return null;
        }
    </script>

    <!-- DRAW MODE MENUS -->
    <script>
        

        const draw_sub_menu = document.getElementById('draw_button_sub_menu');

        function draw(client_x_start, client_x_end, client_y_start, client_y_end) {
            console.log("draw");

            let color_rgba = hsla_to_rgba(color.hue, color.saturation, color.lightness, color.alpha);
            // console.log("color", color);
            // console.log("color_rgba", color_rgba);

            let mouse_x = client_x_start + window.scrollX - CANVAS_X;
            let mouse_y = client_y_start + window.scrollY - CANVAS_Y;
            let mouse_drag_x = client_x_end + window.scrollX - CANVAS_X;
            let mouse_drag_y = client_y_end + window.scrollY - CANVAS_Y;

            const canvas_width = parseFloat(canvas.style.width);
            const zoom_factor = canvas_width / dims.defaultWidth;

            // draw line from previous point to new point
            let pixels = [];
            let dist_x = mouse_x - mouse_drag_x;
            let dist_y = mouse_y - mouse_drag_y;
            let max_dist = Math.max(Math.abs(dist_x), Math.abs(dist_y));
            let step_x = dist_x / max_dist;
            let step_y = dist_y / max_dist;
            for (let i = 0; i < max_dist; i++) {
                let x = step_x * i + mouse_drag_x;
                let y = step_y * i + mouse_drag_y;
                const pixel = {
                    x: Math.floor(x / zoom_factor),
                    y: Math.floor(y / zoom_factor),
                    r: color_rgba.r,
                    g: color_rgba.g,
                    b: color_rgba.b,
                    a: color_rgba.a
                };
                pixels.push(pixel);
            }
            const pixel = {
                x: Math.floor(mouse_x / zoom_factor),
                y:  Math.floor(mouse_y / zoom_factor),
                r: color_rgba.r,
                g: color_rgba.g,
                b: color_rgba.b,
                a: color_rgba.a
            };
            pixels.push(pixel);

            // console.log("color", color);
            // console.log("color_rgba", color_rgba);
            // console.log("pixels", pixels);
            add_to_stroke(pixels, true);


            // console.log("dims.defaultWidth", dims.defaultWidth);
            // console.log("canvas_width", canvas_width);
            // console.log("zoom_factor", zoom_factor);
            // console.log("event.clientX:", event.clientX, "event.clientY:", event.clientY);
            // console.log("window.scrollX:", window.scrollX, "window.scrollY:", window.scrollY);
            // console.log("adj x:", event.clientX + window.scrollX, "adj y", event.clientY + window.scrollY);
            // console.log("x:", mouse_x, "y:", mouse_y);
        }


        const color_icon = document.getElementById('color_icon');
        const draw_size_circle = document.getElementById('draw_size_circle');

        const hue_slider = document.getElementById('hue_slider');
        const saturation_slider = document.getElementById('saturation_slider');
        const lightness_slider = document.getElementById('lightness_slider');
        const alpha_slider = document.getElementById('alpha_slider');

        const hex_value_text = document.getElementById("hex_value_text");
        const hsl_value_text = document.getElementById("hsl_value_text");
        const rgba_value_text = document.getElementById("rgba_value_text");

        const draw_size_slider = document.getElementById('draw_size_slider');


        // slider updates
        function update_hue_slider() {
            hue_slider.style.background = `linear-gradient(to right, 
                hsl(0, 100%, 57%, 100%),
                hsl(30, 100%, 57%, 100%),
                hsl(60, 100%, 57%, 100%),
                hsl(90, 100%, 57%, 100%),
                hsl(120, 100%, 57%, 100%),
                hsl(150, 100%, 57%, 100%),
                hsl(180, 100%, 57%, 100%),
                hsl(210, 100%, 57%, 100%),
                hsl(240, 100%, 57%, 100%),
                hsl(270, 100%, 57%, 100%),
                hsl(300, 100%, 57%, 100%),
                hsl(330, 100%, 57%, 100%)
            )`;
            hue_slider.value = color.hue;
        }

        function update_saturation_slider() {
            saturation_slider.style.background = `linear-gradient(to right, 
                hsl(${color.hue}, 0%, 57%, 100%),
                hsl(${color.hue}, 50%, 57%, 100%),
                hsl(${color.hue}, 100%, 57%, 100%)
            )`;
            saturation_slider.value = color.saturation;
        }

        function update_lightness_slider() {
            lightness_slider.style.background = `linear-gradient(to right, 
                hsl(${color.hue}, 100%, 0%, 100%),
                hsl(${color.hue}, 100%, 10%, 100%),
                hsl(${color.hue}, 100%, 20%, 100%),
                hsl(${color.hue}, 100%, 30%, 100%),
                hsl(${color.hue}, 100%, 40%, 100%),
                hsl(${color.hue}, 100%, 50%, 100%),
                hsl(${color.hue}, 100%, 60%, 100%),
                hsl(${color.hue}, 100%, 70%, 100%),
                hsl(${color.hue}, 100%, 80%, 100%),
                hsl(${color.hue}, 100%, 90%, 100%),
                hsl(${color.hue}, 100%, 100%, 100%)
            )`;
            lightness_slider.value = color.lightness;
        }

        function update_alpha_slider() {
            alpha_slider.style.background = `linear-gradient(to right, 
                hsl(${color.hue}, 100%, 57%, 0%),
                hsl(${color.hue}, 100%, 57%, 10%),
                hsl(${color.hue}, 100%, 57%, 20%),
                hsl(${color.hue}, 100%, 57%, 30%),
                hsl(${color.hue}, 100%, 57%, 40%),
                hsl(${color.hue}, 100%, 57%, 50%),
                hsl(${color.hue}, 100%, 57%, 60%),
                hsl(${color.hue}, 100%, 57%, 70%),
                hsl(${color.hue}, 100%, 57%, 80%),
                hsl(${color.hue}, 100%, 57%, 90%),
                hsl(${color.hue}, 100%, 57%, 100%)
            )`;
            alpha_slider.value = color.alpha;
        }

        hue_slider.addEventListener('input', () => {
            color.hue = hue_slider.value;
            update_saturation_slider();
            update_lightness_slider();
            update_alpha_slider();
            update_color_label();
        });

        saturation_slider.addEventListener('input', () => {
            color.saturation = saturation_slider.value;
            update_hue_slider();
            update_lightness_slider();
            update_alpha_slider();
            update_color_label();
        });

        lightness_slider.addEventListener('input', () => {
            color.lightness = lightness_slider.value;
            update_hue_slider();
            update_saturation_slider();
            update_alpha_slider();
            update_color_label();
        });

        alpha_slider.addEventListener('input', () => {
            color.alpha = alpha_slider.value;
            update_hue_slider();
            update_saturation_slider();
            update_lightness_slider();
            update_color_label();
        });

        function update_color_label() {
            // console.log("color", color);
            color_icon.style.backgroundColor = `hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%)`;
            draw_size_circle.style.backgroundColor = `hsl(${color.hue}, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%)`;
            

            const rgba = hsla_to_rgba(color.hue, color.saturation, color.lightness, color.alpha);
            hex_value_text.value = rgba_to_hex(rgba.r, rgba.g, rgba.b, rgba.a);

            hsl_value_text.value = `${color.hue}°, ${color.saturation}%, ${color.lightness}%, ${color.alpha}%`;

            rgba_value_text.value = `${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a}`;
        }

        // draw size slider stuff
        draw_size_slider.addEventListener('input', () => {
            update_draw_size_circle();
        });
        function update_draw_size_circle() {
            brush_radius = draw_size_slider.value;

            // convert to a visual size for the zoom of the canvas
            const scale_difference = width / dims.defaultWidth;
            const visual_brush_size = brush_radius * scale_difference;
            // console.log("visual_brush_size", visual_brush_size);

            draw_size_circle.style.width = visual_brush_size + "px";
            draw_size_circle.style.height = visual_brush_size + "px";
            draw_size_circle.style.borderRadius = visual_brush_size + "px";
        }

        // color picker
        function color_picker_click() {
            color_pick = !color_pick;

            const color_picker = document.getElementById("color_picker");
            const color_picker_svg = document.getElementById("color_picker_svg");
            

            if (color_pick) {
                color_picker.style.backgroundColor = 'var(--accent-color)';
                color_picker_svg.setAttribute('fill', 'var(--secondary-color)');
                color_picker_svg.setAttribute('stroke', 'var(--secondary-color)');
            }
            else {
                color_picker.style.backgroundColor = 'var(--secondary-color)';
                color_picker_svg.setAttribute('fill', 'var(--accent-color)');
                color_picker_svg.setAttribute('stroke', 'var(--accent-color)');
            }


        }

        function set_color_rgba(r, g, b, a) {
            const hsla_con = rgba_to_hsla(r, g, b, a);
            console.log("hsla_con", hsla_con);
            set_color(hsla_con.hue, hsla_con.saturation, hsla_con.lightness, hsla_con.alpha);
        }

        function set_color(h, s, l, a) {
            color = {
                hue: h,
                saturation: s,
                lightness: l,
                alpha: a
            };
            console.log("color", color);
            // console.log(h, s, l, a);

            update_hue_slider();
            update_saturation_slider();
            update_lightness_slider();
            update_alpha_slider();

            update_color_label();
        }

        // #bd0f0f

        // color text values
        hex_value_text.addEventListener('focus', () => {
            typing = true;
        });
        hex_value_text.addEventListener('blur', () => {

            try {
                let hex_value = hex_value_text.value;
                let rgba_color = hex_to_rgba(hex_value);
                // console.log("rgba_color", rgba_color);

                let null_vals = rgba_color.r == null || rgba_color.g == null || rgba_color.b == null || rgba_color.a == null;
                let low = rgba_color.r < 0 || rgba_color.g < 0 || rgba_color.b < 0 || rgba_color.a < 0;
                let high = rgba_color.r > 255 || rgba_color.g > 255 || rgba_color.b > 255 || rgba_color.a > 255;
                if (null_vals || low || high) {
                    throw new Error();
                }
                console.log("rgba_color", rgba_color);
                set_color_rgba(rgba_color.r, rgba_color.g, rgba_color.b, rgba_color.a);
            }
            catch(error) {
                alert("Couldn't parse color: '" + hex_value_text.value + "'");
            }
            typing = false;
        });
        hsl_value_text.addEventListener('focus', () => {
            typing = true;
        });
        hsl_value_text.addEventListener('blur', () => {
            try {
                let hsla_value = hsl_value_text.value.replace(/\s+/g, '');
                const hue_and_rest = hsla_value.split('°,');
                const hue = parseInt(hue_and_rest[0]);
                hsl_value = hue_and_rest[1];
                const vals = hsl_value.split('%,');
                const saturation = parseInt(vals[0]);
                const lightness = parseInt(vals[1]);
                let alpha = 100;
                if (vals.length > 2) {
                    alpha = parseInt(vals[2].substring(0, vals[2].length-1));
                }

                let null_vals = hue == null || saturation == null || lightness == null || !alpha == null;
                let low = hue < 0 || saturation < 0 || lightness < 0 || alpha < 0;
                let high = hue > 360 || saturation > 100 || lightness > 100 || alpha > 100;
                if (null_vals || low || high) {
                    console.log(hue, saturation, lightness, alpha);
                    console.log(null_vals,low,high);
                    throw new Error();
                }

                set_color(hue, saturation, lightness, alpha);
            }
            catch(error) {
                console.log(error);
                alert("Couldn't parse color: '" + hsl_value_text.value + "'");
            }
            typing = false;
        });
        rgba_value_text.addEventListener('focus', () => {
            typing = true;
        });
        rgba_value_text.addEventListener('blur', () => {

            try {
                let rgba_value = rgba_value_text.value.replace(/\s+/g, '');
                const vals = rgba_value.split(',');
                const r = parseInt(vals[0]);
                const g = parseInt(vals[1]);
                const b = parseInt(vals[2]);
                let a = 255;

                if (vals.length > 3) {
                    a = parseInt(vals[3]);
                }

                let null_vals = r == null || g == null || b == null || a == null;
                let low = r < 0 || g < 0 || b < 0 || a < 0;
                let high = r > 255 || g > 255 || b > 255 || a > 255;
                if (null_vals || low || high) {
                    console.log(r,g,b,a);
                    throw new Error();
                }
                set_color_rgba(r, g, b, a);
            }
            catch(error) {
                console.log(error);
                alert("Couldn't parse color: '" + rgba_value_text.value + "'");
            }
            typing = false;
        });


        // draw button toggling
        function draw_button_click() {
            // console.log("clicked");


            turn_off_other_modes("draw");
            draw_mode = !draw_mode;

            const draw_button = document.getElementById("draw_button");
            const draw_svg = document.getElementById("draw-svg");
            
            if (draw_mode) {
                draw_button.style.backgroundColor = 'var(--accent-color)';
                draw_svg.setAttribute('fill', 'var(--secondary-color)');
                draw_svg.setAttribute('stroke', 'var(--secondary-color)');
                place_draw_sub_menu();
            }
            else {
                turn_off_draw_mode();
            }

            
            update_color_label();
            draw_size_slider.value = brush_radius;
            update_draw_size_circle();
            // draw_button.classList.remove("draw_button-selected");
        }

        function turn_off_draw_mode() {
            draw_mode = false;
            const draw_button = document.getElementById("draw_button");
            const draw_svg = document.getElementById("draw-svg");
            draw_button.style.backgroundColor = 'var(--secondary-color)';
            draw_svg.setAttribute('fill', 'var(--accent-color)');
            draw_svg.setAttribute('stroke', 'var(--accent-color)');
            draw_sub_menu.style.display = 'none';

        }

        function place_draw_sub_menu() {
            const draw_button = document.getElementById('draw_button');
            draw_sub_menu.style.display = 'flex';

            const rect = draw_button.getBoundingClientRect();
            draw_sub_menu.style.top = (rect.top) + 'px';
            draw_sub_menu.style.left = (rect.right + 5) + 'px';
            // console.log(rect);

            hue_slider.value = color.hue;
            saturation_slider.value = color.saturation;
            lightness_slider.value = color.lightness;
            alpha_slider.value = color.alpha;
        }


        const color_wheel = document.getElementById('color_wheel');
        let color_wheel_scroll_offset = 0;

        function display_color_wheel() {
            const numDivs = color_wheel.children.length; // Number of squares
            const radius = color_wheel.offsetWidth * 0.5 * 0.8; // Radius in pixels
            let centerX = color_wheel.offsetWidth / 2;
            let centerY = color_wheel.offsetHeight / 2;

            for (let i = 0; i < numDivs; i++) {
                const div = color_wheel.children[i];
                let angle = (i / numDivs) * 2 * Math.PI;
                angle += color_wheel_scroll_offset;

                // Position
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                div.style.left = `${x}px`;
                div.style.top = `${y}px`;

                // Rotate the square so that it's tangent to the circle at that point
                // The tangent is perpendicular to the radius, so add 90°
                const rotationDeg = (angle * 180 / Math.PI) + 90;
                div.style.transform = `translate(-50%, -50%) rotate(${rotationDeg}deg)`;
            }
        }
        display_color_wheel();
    </script>

    <!-- MOVE MODE -->
    <script>

        let move_select_start_x = null;
        let move_select_start_y = null;
        let move_select_end_x = null;
        let move_select_end_y = null;

        function move_mode_button_click() {
            // console.log("clicked");

            turn_off_other_modes("move");
            move_mode = !move_mode;

            const move_mode_button = document.getElementById("move_button");
            const move_svg = document.getElementById("move_svg");
            

            if (move_mode) {
                move_mode_button.style.backgroundColor = 'var(--accent-color)';
                move_svg.setAttribute('fill', 'var(--secondary-color)');
                move_svg.setAttribute('stroke', 'var(--secondary-color)');
            }
            else {
                turn_off_move_mode();
            }


        }

        function turn_off_move_mode() {
            move_mode = false;
            const move_mode_button = document.getElementById("move_button");
            const move_svg = document.getElementById("move_svg");
            move_mode_button.style.backgroundColor = 'var(--secondary-color)';
            move_svg.setAttribute('fill', 'var(--accent-color)');
            move_svg.setAttribute('stroke', 'var(--accent-color)');
        }

        function draw_select_box() {
            // console.log("draw_select_box");

            let already_created = true;
            select_box = document.getElementById("select_box");
            if (!select_box) {
                select_box = document.createElement('div');
                document.getElementById('paint-background').appendChild(select_box);
            }
            select_box.id = 'select_box';

            // Set the position of the box (you can change these values)
            const left = Math.min(move_select_start_x, move_select_end_x) + 'px';
            const top = Math.min(move_select_start_y, move_select_end_y) + 'px';
            const box_width = Math.abs(move_select_start_x - move_select_end_x) + 'px';
            const box_height = Math.abs(move_select_start_y - move_select_end_y) + 'px';
            select_box.style.left = left; // Position from the left
            select_box.style.top = top; // Position from the top
            select_box.style.width = box_width;
            select_box.style.height = box_height;
            // draw_sub_menu.style.top = (rect.top) + 'px';
            // draw_sub_menu.style.left = (rect.right + 5) + 'px';
            // console.log("left", left);
            // console.log("top", top);
            // console.log("box_width", box_width);
            // console.log("box_height", box_height);

            // select_box.addEventListener('blur', function() {
            //     select_box.remove(); 
            // });
        }

        function remove_select_box() {
            move_select_start_x = null;
            move_select_start_y = null;
            move_select_end_x = null;
            move_select_end_y = null;
            select_box.remove();
        }

        function select_strokes() {
            // console.log("select_strokes");
            let box_start_x = mouse_x_to_canvas_x(move_select_start_x);
            let box_start_y = mouse_y_to_canvas_y(move_select_start_y);
            let box_end_x = mouse_x_to_canvas_x(move_select_end_x);
            let box_end_y = mouse_y_to_canvas_y(move_select_end_y);
            // consoa.log("box_end_y", box_end_y);

            let step_x = box_end_x - box_start_x > 0? 1 : -1;
            let step_y = box_end_y - box_start_y > 0? 1 : -1;
            

            let xy_coordinates = [];
            for(let x = box_start_x; x != box_end_x; x += step_x) {
                for(let y = box_start_y; y != box_end_y; y += step_y) {
                    xy_coordinates.push({
                        x:x,
                        y:y
                    });
                }
            }

            // console.log("xy_coordinates", xy_coordinates);

            save_canvas_and_get_selected_strokes(xy_coordinates);

        }

        function update_move_draw_select_box(delta_x, delta_y) {

            // console.log("update_move_draw_select_box");
            const top = parseFloat(select_box.style.getPropertyValue('top'));
            const left = parseFloat(select_box.style.getPropertyValue('left'));
            select_box.style.top = (top + delta_y) + 'px';
            select_box.style.left = (left + delta_x) + 'px';
        }

    </script>

    <!-- SETTINGS MENU -->
    <script>

        const settings_button = document.getElementById('settings_button');
        const settings_sub_menu = document.getElementById('settings_sub_menu');
        const settings_svg = document.getElementById('settings_svg');
        function settings_button_click() {
            turn_off_other_modes("settings")
            in_settings = !in_settings;
            if (in_settings) {
                settings_button.style.backgroundColor = 'var(--accent-color)';
                settings_svg.setAttribute('fill', 'var(--secondary-color)');
                settings_svg.setAttribute('stroke', 'var(--secondary-color)');
                place_settings_sub_menu();
            }
            else {
                turn_off_settings();
            }

        }

        function turn_off_settings() {
            const settings_button = document.getElementById('settings_button');
            const settings_sub_menu = document.getElementById('settings_sub_menu');
            const settings_svg = document.getElementById('settings_svg');
            settings_button.style.backgroundColor = 'var(--secondary-color)';
            settings_svg.setAttribute('fill', 'var(--accent-color)');
            settings_svg.setAttribute('stroke', 'var(--accent-color)');
            settings_sub_menu.style.display = 'none';

        }

        function place_settings_sub_menu() {
            settings_sub_menu.style.display = 'flex';

            const rect = settings_button.getBoundingClientRect();
            settings_sub_menu.style.top = (rect.top) + 'px';
            settings_sub_menu.style.left = (rect.right + 5) + 'px';


            const canvas_width_input = document.getElementById('canvas_width_input');
            canvas_width_input.value = canvas.width;
            const canvas_height_input = document.getElementById('canvas_height_input');
            canvas_height_input.value = canvas.height;
        }



        function set_canvas_resize() {

            let resize = {
                width: dims.defaultWidth, 
                height: dims.defaultHeight 
            };
            add_action(
                RESIZE_CANVAS, 
                resize
            );
        }

        const canvas_width_input = document.getElementById('canvas_width_input');
        const canvas_height_input = document.getElementById('canvas_height_input');
        canvas_width_input.addEventListener('input', () => {
            canvas_resize();
        });
        canvas_height_input.addEventListener('input', () => {
            canvas_resize();
        });
        canvas_width_input.addEventListener('focus', () => {
            set_canvas_resize();
        });
        canvas_height_input.addEventListener('focus', () => {
            set_canvas_resize();
        });

        function canvas_resize() {

            dims.defaultWidth = parseInt(canvas_width_input.value);
            dims.defaultHeight = parseInt(canvas_height_input.value);

            draw_canvas_and_center_view();
        }


        const image_background_input = document.getElementById('image_background_input');
        image_background_input.addEventListener('change', () => {
            const file = image_background_input.files[0];
            if (!file) return;

            if (file.type.startsWith('image/') && !file.type.startsWith('image/svg')) {
                const reader = new FileReader();
                reader.onload = function () {
                    

                    // add for undo
                    add_action(SET_BACKGROUND, get_background_data_for_undo());


                    // scale canvas to image size
                    const img = new Image();
                    img.src = reader.result;
                    img.onload = () => {
                        // resize canvas
                        canvas_width_input.value = img.width;
                        canvas_height_input.value = img.height;
                        canvas_resize();
                        
                        // clear and draw
                        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0); // Draw the image at coordinates (0, 0)
                        
                        // Get pixel data
                        canvas_background_img = [];
                        const img_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        for (let i = 0; i < img_data.data.length; i+=4) {
                            // const index = Math.round(pixel.y * canvas.width + pixel.x) * 4;
                            let pixel_i = Math.floor(i / 4);
                            let y = Math.floor(pixel_i / img.width);
                            let x = pixel_i - (y * img.width);
                            canvas_background_img.push({
                                x: x,
                                y: y,
                                r: img_data.data[i],
                                g: img_data.data[i+1],
                                b: img_data.data[i+2],
                                a: img_data.data[i+3]
                            });
                        }

                        //re draw
                        re_draw();


                    };


                };
                reader.readAsDataURL(file);

            }
            else {
                alert(file.type + " isn't a supported file type");
            }
            
        });
    
        const background_color_input = document.getElementById('background_color_input');
        const background_color_view = document.getElementById('background_color_view');
        background_color_input.addEventListener('keydown', function(event) {
            typing = true;
            if (event.key === 'Enter') {
                typing = false;
                set_background_color()
            }
        });
        background_color_input.addEventListener('blur', function() {
            typing = false;
            set_background_color()
        });
        function set_background_color() {

            // add for undo
            add_action(SET_BACKGROUND, get_background_data_for_undo());

            try {
                canvas_background_color = hex_to_rgba(background_color_input.value);
            }
            catch(error) {
                background_color_input.value = rgba_to_hex(canvas_background_color.r, canvas_background_color.g, canvas_background_color.b, canvas_background_color.a);
            }
            console.log("canvas_background_color", canvas_background_color);
            background_color_view.style.backgroundColor = `rgba(${canvas_background_color.r}, ${canvas_background_color.g}, ${canvas_background_color.b}, ${canvas_background_color.a / 255})`;
            
            re_draw();
        }
        background_color_input.value = rgba_to_hex(canvas_background_color.r, canvas_background_color.g, canvas_background_color.b, canvas_background_color.a);
        background_color_view.style.backgroundColor = `rgba(${canvas_background_color.r}, ${canvas_background_color.g}, ${canvas_background_color.b}, ${canvas_background_color.a / 255})`;
            

    </script>

    <!-- Erase -->
     <script>

        function erase_button_click() {
            // console.log("clicked");

            turn_off_other_modes('erase');
            erase_mode = !erase_mode;

            const erase_button = document.getElementById("erase_button");
            const erase_svg = document.getElementById("erase_svg");
            

            if (erase_mode) {
                erase_button.style.backgroundColor = 'var(--accent-color)';
                erase_svg.setAttribute('fill', 'var(--secondary-color)');
                erase_svg.setAttribute('stroke', 'var(--secondary-color)');
            }
            else {
                turn_off_erase_mode();
            }


        }

        function turn_off_erase_mode() {
            const erase_button = document.getElementById("erase_button");
            const erase_svg = document.getElementById("erase_svg");
            erase_button.style.backgroundColor = 'var(--secondary-color)';
            erase_svg.setAttribute('fill', 'var(--accent-color)');
            erase_svg.setAttribute('stroke', 'var(--accent-color)');
        }

     </script>

    <!-- UNDO OR CTRL Z -->
    <script>
        const MAX_ACTIONS = 200;
        let actions = [];
        let undone_actions = [];
        
        function add_action(type, data) {
            actions.push(
                make_action(type, data)
            );
            undone_actions = [];

            const last = actions[actions.length - 1];

            console.log("action", type);
            console.log("data", last.data);
        }

        function make_action(type, data) {
            return {
                type: type,
                data: JSON.parse(JSON.stringify(data))
            };
        }

        const ADD_STROKE = "ADD_STROKE";
        const MOVE_STROKES = "MOVE_STROKES";
        const SET_BACKGROUND = "SET_BACKGROUND";
        const ERASE_STROKE = "ERASE_STROKE";
        const RESIZE_CANVAS = "RESIZE_CANVAS";
        function undo() {

            if (actions.length > 0) {
                console.log("undo");
                const action = actions.pop();

                if (action.type == ADD_STROKE) {
                    console.log("undo ADD_STROKE");
                    const stroke = action.data;
                    undone_actions.push(
                        make_action(ADD_STROKE, stroke)
                    );
                    // console.log("stroke", stroke);

                    remove_stroke(stroke.uuid);
                }
                else if (action.type == MOVE_STROKES) {
                    console.log("undo MOVE_STROKES");
                    const strokes = action.data;

                    // add to undone actions
                    const strokes_current_pos = strokes.map(moved_stroke => {
                        return uuid_to_stroke.get(moved_stroke.uuid);
                    });
                    undone_actions.push(
                        make_action(MOVE_STROKES, strokes_current_pos)
                    );

                    strokes.forEach(moved_stroke => {
                        remove_stroke(moved_stroke.uuid);
                        stroke_uuid = moved_stroke.uuid;
                        stroke = moved_stroke;
                        // console.log("moved_stroke", moved_stroke);
                        add_stroke(moved_stroke.pixels);
                        finish_stroke(false);
                    });
                }
                else if (action.type == SET_BACKGROUND) {
                    console.log("undo SET_BACKGROUND");

                    undone_actions.push(
                        make_action(SET_BACKGROUND, get_background_data_for_undo())
                    );

                    reset_background(action.data);
                }
                else if (action.type == ERASE_STROKE) {
                    console.log("undo ERASE_STROKE");

                    undone_actions.push(
                        make_action(ERASE_STROKE, action.data)
                    );

                    const removed_stroke = action.data;
                    stroke_uuid = removed_stroke.uuid;
                    stroke = removed_stroke;
                    // console.log("removed_stroke", removed_stroke);
                    add_stroke(removed_stroke.pixels);
                    finish_stroke(false);
                }
                else if (action.type == RESIZE_CANVAS) {
                    console.log("undo RESIZE_CANVAS");

                    undone_actions.push(
                        make_action(
                            RESIZE_CANVAS, 
                            {
                                width: dims.defaultWidth, 
                                height: dims.defaultHeight 
                            }
                        )
                    );

                    canvas_width_input.value = action.data.width;
                    canvas_height_input.value = action.data.height;
                    canvas_resize();

                }
                
                console.log("actions", actions);
                console.log("undone_actions", undone_actions);
            }
        }

        function redo() {

            if (undone_actions.length > 0) {
                console.log("redo");
                const action = undone_actions.pop();

                if (action.type == ADD_STROKE) {
                    console.log("redo ADD_STROKE");
                    const removed_stroke = action.data;
                    stroke_uuid = removed_stroke.uuid;
                    stroke = removed_stroke;
                    // console.log("removed_stroke", removed_stroke);
                    add_stroke(removed_stroke.pixels);
                    finish_stroke(false);
                    actions.push(
                        make_action(ADD_STROKE, removed_stroke)
                    );
                }
                else if (action.type == MOVE_STROKES) {
                    console.log("redo MOVE_STROKES");
                    console.log("action", action);
                    const strokes = action.data;

                    // add to actions
                    const strokes_current_pos = strokes.map(moved_stroke => {
                        return uuid_to_stroke.get(moved_stroke.uuid);
                    });
                    actions.push(
                        make_action(MOVE_STROKES, strokes_current_pos)
                    );

                    strokes.forEach(moved_stroke => {
                        remove_stroke(moved_stroke.uuid);
                        stroke_uuid = moved_stroke.uuid;
                        stroke = moved_stroke;
                        // console.log("moved_stroke", moved_stroke);
                        add_stroke(moved_stroke.pixels);
                        finish_stroke(false);
                    });
                }
                else if (action.type == SET_BACKGROUND) {
                    console.log("redo SET_BACKGROUND");

                    actions.push(
                        make_action(SET_BACKGROUND, get_background_data_for_undo())
                    );

                    reset_background(action.data);
                }
                else if (action.type == ERASE_STROKE) {
                    console.log("redo ERASE_STROKE");

                    const removed_stroke = action.data;
                    actions.push(
                        make_action(ERASE_STROKE, removed_stroke)
                    );
                    // console.log("stroke", stroke);

                    remove_stroke(removed_stroke.uuid);
                }
                else if (action.type == RESIZE_CANVAS) {
                    console.log("redo RESIZE_CANVAS");

                    canvas_width_input.value = action.data.width;
                    canvas_height_input.value = action.data.height;
                    canvas_resize();

                }

                console.log("actions", actions);
                console.log("undone_actions", undone_actions);
            }
        }

        function get_background_data_for_undo() {
            let data = {};
            if (canvas_background_img) {
                data.background_img = canvas_background_img;
            }
            else {
                data.background_color = canvas_background_color;
            }

            data.canvas_width = parseInt(canvas_width_input.value);
            data.canvas_height = parseInt(canvas_height_input.value);

            return data;
        } 

        function reset_background(data) {

            if (data.background_img) {
                canvas_background_img = data.background_img;
            }
            else {
                canvas_background_color = data.background_color;
                canvas_background_img = null;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas_width_input.value = data.canvas_width;
            canvas_height_input.value = data.canvas_height;
            canvas_resize();
            re_draw();
        }

    </script>

    <!-- download dialog -->
     <script>
        const download_popup = document.getElementById("download_popup");
        function download_image() {
            let file_name = document.getElementById("file_name_input").value;
            file_name = file_name.split('.');

            const link = document.createElement('a'); // Create a temporary link
            link.download = file_name + '.png'; // Set the desired file name
            link.href = canvas.toDataURL('image/png'); // Convert canvas to PNG data URL
            link.click(); // Programmatically click the link to trigger download

            close_download_dialog();
        }

        function download_dialog() {

            turn_off_other_modes('none');
            download_popup.style.display = "block";
            typing = true;
        }

        function close_download_dialog() {
            download_popup.style.display = "none";
            typing = false;

        }


        download_popup.addEventListener('click', (event) => {
            console.log(event.target)
            if (event.target === download_popup) {
                close_download_dialog();
            }
        });
        
        

     </script>

    <!-- WINDOW INPUT HANDLING -->
    <script>
        const CANVAS_X = 40000; 
        const CANVAS_Y = 40000; 
        let ctrl = false; // Control flag
        let shift = false; // Shift flag


        document.addEventListener('DOMContentLoaded', () => {
            
            draw_canvas_and_center_view();

            // draw_button_click();

            return () => {
            };
        });

        function draw_canvas_and_center_view() {
            let windowWidth = window.innerWidth;
            let windowHeight = window.innerHeight;
            
            width = dims.defaultWidth;
            height = dims.defaultHeight;

            // Set initial canvas size
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width;
            canvas.height = height;
            draw_canvas_background();

            // const rect = canvas.getBoundingClientRect();
            // let canvasX = rect.left + window.scrollX;
            // let canvasY = rect.top + window.scrollY;
            // console.log('canvasX', canvasX);
            // console.log('canvasY', canvasY);

            // Center the scroll
            window.scrollTo(CANVAS_X - windowWidth / 2 + width / 2, CANVAS_Y - windowHeight / 2 + height / 2);
            console.log('window:', windowWidth, windowHeight);
            // console.log('width', width);
            // console.log('height', height);
            // console.log('windowWidth', windowWidth);
            // console.log('windowHeight', windowHeight);

            // starter_stroke(100, 100);
            // starter_stroke(300, 100);
            zoom_to_fit_canvas_to_view();

            re_draw();
        }

        const handleKeyDown = (event) => {
            if ((event.ctrlKey && event.key === 'Control') || (event.metaKey && event.key === 'Meta')) {
                ctrl = true;
            }
            else if (event.key === 'Shift') {
                shift = true;
            }
            else if (!event.ctrlKey && !typing && event.key === 'a') {
                draw_button_click();
            }
            else if (!event.ctrlKey && !typing && event.key === 's') {
                move_mode_button_click();
            }
            else if (!event.ctrlKey && !typing && event.key === 'd') {
                erase_button_click();
            }
            else if (!event.ctrlKey && !typing && event.key === 'f') {
                download_dialog();
            }
            else if (!event.ctrlKey && !typing && event.key === 'g') {
                settings_button_click();
            }
            else if (event.key === ' ') {
                event.preventDefault();
                console.log("space");
            }
            else if (ctrl && shift && event.key == 'z') {
                redo();
            }
            else if (ctrl && event.key == 'z') {
                undo();
            }
            
        };
        window.addEventListener('keydown', handleKeyDown);
        
        const handleKeyUp = (event) => {
            if (event.key === 'Control' || event.key === 'Meta') {
                ctrl = false;
            }
            else if (event.key === 'Shift') {
                shift = false;
            }
        };
        window.addEventListener('keyup', handleKeyUp);
        
        let is_dragging = false;
        const handleMouseDown = (event) => {
            
            if (event.button == 0) {
                is_dragging = true; // Set dragging to true
                drag_x = event.clientX; // Get the starting X coordinate
                drag_y = event.clientY; // Get the starting Y coordinate


                // remove box selection if clicking off the box
                if (select_box && !select_box.contains(event.target)) {
                    remove_select_box();
                }

                if (draw_mode) {
                    if (event.target == canvas) {
                        if (color_pick) {
                            console.log("pick color");
                            let x = mouse_x_to_canvas_x(event.clientX);
                            let y = mouse_y_to_canvas_y(event.clientY);
                            const [r, g, b, a] = ctx.getImageData(x, y, 1, 1).data;
                            console.log(r, g, b, a);
                            set_color_rgba(r, g, b, a);
                            color_picker_click();
                        }
                        else {
                            drawing = true;
                            draw(event.clientX, event.clientX, event.clientY, event.clientY);
                        }
                    }
                }
                else if (move_mode) {
                    let ctrl = event.metaKey || event.ctrlKey;

                    // box select vs single stroke select
                    if (ctrl) {
                        draw_box_select = true;
                        move_select_start_x = event.clientX;
                        move_select_start_y = event.clientY;
                        move_select_end_x = event.clientX;
                        move_select_end_y = event.clientY;
                    }
                    else if (event.target == select_box) {
                        move_box_select = true;
                        select_strokes();
                        // console.log("selected_strokes", selected_strokes);
                    }
                    else if (event.target == canvas) {
                        let x = mouse_x_to_canvas_x(event.clientX);
                        let y = mouse_y_to_canvas_y(event.clientY);
                        save_canvas_and_get_selected_strokes([
                            {
                                x:x, 
                                y:y
                            }
                        ]);
                    }
                }
                else if (erase_mode) {
                    const most_recent = get_most_recent_stroke_at_xy(event.clientX, event.clientY);
                    remove_stroke(most_recent.uuid);
                    add_action(ERASE_STROKE, most_recent);
                }


            }
        };
        window.addEventListener('mousedown', handleMouseDown);
        
        const handleMouseMove = (event) => {
            if (is_dragging) {
                if (draw_mode && event.target == canvas) {
                    draw(event.clientX, drag_x, event.clientY, drag_y);
                }
                else if (move_box_select && (event.target == canvas || event.target == select_box)) {
                    update_selected_stroke(event.clientX, event.clientY);
                    const delta_x = event.clientX - drag_x;
                    const delta_y = event.clientY - drag_y;
                    update_move_draw_select_box(delta_x, delta_y);
                }
                else if (draw_box_select) {
                    move_select_end_x = event.clientX;
                    move_select_end_y = event.clientY;
                    draw_select_box();
                }
                else if (move_mode && selected_strokes && event.target == canvas) {
                    update_selected_stroke(event.clientX, event.clientY);
                }
                else if (!drawing && !draw_sub_menu.contains(event.target) && !settings_sub_menu.contains(event.target)){
                    // console.log("move");
                    const delta_x = event.clientX - drag_x;
                    const delta_y = event.clientY - drag_y;
                    window.scrollTo(window.scrollX - delta_x, window.scrollY - delta_y);
                }

                drag_x = event.clientX;
                drag_y = event.clientY;
            }
        };
        window.addEventListener('mousemove', handleMouseMove);
        
        const handleMouseUp = (event) => {
            // console.log("mouseUp");a
            is_dragging = false;
            if (draw_mode && drawing) {
                drawing = false;
                finish_stroke(true);
            }
            else if (move_mode) {
                if (move_box_select) {
                    drop_selected_stroke();
                    move_box_select = false;
                    remove_select_box();
                }
                else if (draw_box_select) {
                    draw_box_select = false;
                }
                else if (move_mode && selected_strokes){
                    drop_selected_stroke();
                }
            }
        };
        window.addEventListener('mouseup', handleMouseUp);

        const handleScroll = (event) => {
            event.preventDefault(); // Prevent default scroll action

            if (color_wheel.contains(event.target)) {
                color_wheel_scroll_offset += event.deltaY * 0.002;
                display_color_wheel();
            }
            else {
                // determine mouse location on canvas
                let mouseX = event.clientX; // gets absolute mouse pos not just in viewport
                let mouseY = event.clientY;
                
                scroll(mouseX, mouseY, event.deltaY)

                if (draw_mode) {
                    update_draw_size_circle();
                }
            }
            
        };
        let zoom = 8; // Default zoom level
        const MAX_ZOOM = 10.1;
        function scroll(x, y, zoom_amount) {
            // console.log('canvas_location_x_percent', canvas_location_x_percent);
            // console.log('canvas_location_y_percent', canvas_location_y_percent);


            // console.log("zooming");
            let scrollAmount = -zoom_amount;
            zoom += scrollAmount / 1200;
            if (zoom < 8) zoom = 8; // Minimum zoom
            if (zoom > MAX_ZOOM) zoom = MAX_ZOOM; // Maximum zoom

            let zoomFactor = 100 * 100 ** (zoom - MAX_ZOOM);
            // console.log('zoom', zoom);a

            const canvas_location_x_percent = (x + window.scrollX - CANVAS_X) / width;
            const canvas_location_y_percent = (y + window.scrollY - CANVAS_Y) / height;


            // Modify canvas size
            width = dims.defaultWidth * zoomFactor;
            height = dims.defaultHeight * zoomFactor;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            // Center the zoom on mouse position
            // console.log('mouseX', mouseX);
            // console.log('mouseY', mouseY);
            // console.log('width', width);
            // console.log('height', height);

            /*

                determine pixel where mouse is
                determine same pixel in new canvas

                determine mouse distance from center screen
            */

            const canvas_location_x = canvas_location_x_percent * width;
            const canvas_location_y = canvas_location_y_percent * height;
            const mouse_offset_x = x;
            const mouse_offset_y = y;
            // console.log('mouse_offset_x', mouse_offset_x);
            // console.log('mouse_offset_y', mouse_offset_y);

            window.scrollTo({
                left: 40000 - mouse_offset_x + canvas_location_x,   // X position
                top: 40000 - mouse_offset_y + canvas_location_y,    // Y position
                // behavior: 'smooth' // Enables smooth scroll
            });

            // redraw open menus
            if (draw_mode){
                place_draw_sub_menu();
            }
        }
        function zoom_to_fit_canvas_to_view() {
            
            let windowWidth = window.innerWidth;
            let desired_width = windowWidth * 0.6;
            let desired_height = dims.defaultWidth * canvas.width / canvas.height;

            let desired_zoom_factor = desired_width / dims.defaultWidth;

            /*
                let zoomFactor = 100 * 100 ^ (zoom - MAX_ZOOM) -- see above in the scroll function

                log(zoomFactor / 100) = log(100 ^ (zoom - MAX_ZOOM))
                
                log(zoomFactor / 100) = (zoom - MAX_ZOOM) * log(100)

                log(zoomFactor / 100) / log(100) = zoom - MAX_ZOOM

                zoom = log(zoomFactor / 100) / log(100) + MAX_ZOOM

            */
            let desired_zoom = ( Math.log(desired_zoom_factor / 100) / Math.log(100) ) + MAX_ZOOM;
            zoom = desired_zoom; // set persistant zoom variable and then just scroll 0 on that below


            scroll(window.innerWidth / 2, window.innerHeight / 2, 0);
            
        }
        window.addEventListener('wheel', handleScroll, { passive: false });
        

        // DELETE THIS testing stuffaa
        // starter_stroke(100, 100);
        // draw_button_click();

        // console.log("rgba_to_hsla", rgba_to_hsla(255, 234, 123, 234));
        // console.log("hsla_to_rgba", hsla_to_rgba(50, 100, 74, 91.76));
        

        // TEST
        function starter_stroke(start_x, start_y) {
            let pixels = [];
            for (let x = start_x; x < start_x + 100; x++) {
                for (let y = start_y; y < start_y + 100; y++) {
                    const pixel = {
                        x: x,
                        y: y,
                        r: 255,
                        g: 0,
                        b: 0,
                        a: 255
                    };
                    pixels.push(pixel);
                }
            }

            add_to_stroke(pixels, false);
            finish_stroke(true);
        }
    
    
        function turn_off_other_modes(current_mode) {
            if (move_mode && current_mode != "move") {
                turn_off_move_mode();
            }
            if (draw_mode && current_mode != "draw") {
                turn_off_draw_mode();
            }
            if (in_settings && current_mode != "settings") {
                turn_off_settings();
            }
            if (erase_mode && current_mode != "erase") {
                turn_off_erase_mode();
            }
        }
    </script>

    <!-- COPY PASTE AND DRAG AND DROP IMAGES -->
    <script>
        
        function load_image(file) {

            if (file.type.startsWith('image/') && !file.type.startsWith('image/svg')) {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {

                        const img = new Image();
                        img.src = reader.result;
                        img.onload = () => {

                            // resize canvas to cature image
                            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0); // Draw the image at coordinates (0, 0)
                            
                            // Get pixel data
                            let added_image_pixels = [];
                            const img_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            for (let i = 0; i < img_data.data.length; i+=4) {
                                // const index = Math.round(pixel.y * canvas.width + pixel.x) * 4;
                                let pixel_i = Math.floor(i / 4);
                                let y = Math.floor(pixel_i / img.width);
                                let x = pixel_i - (y * img.width);
                                added_image_pixels.push({
                                    x: x,
                                    y: y,
                                    r: img_data.data[i],
                                    g: img_data.data[i+1],
                                    b: img_data.data[i+2],
                                    a: img_data.data[i+3]
                                });
                            }
                            console.log("added_image_pixels", added_image_pixels);

                            // reset canvas
                            canvas.width = dims.defaultWidth;
                            canvas.height = dims.defaultHeight;
                            draw_canvas_background();
                            re_draw();

                            // add image as a stroke
                            add_to_stroke(added_image_pixels);
                            finish_stroke(true);

                        };
                    };
                    
                    reader.readAsDataURL(file); // Read the image as Data URL
            }
            else {
                alert(file.type + " isn't a supported file type");
            }
            
        }

        // Drag and drop handling
        canvas.addEventListener('dragover', (event) => {
            event.preventDefault(); // Prevent default to allow drop
        });

        canvas.addEventListener('drop', (event) => {
            console.log("drop");
            event.preventDefault();
            const files = event.dataTransfer.files;

            if (files.length > 0) {
                const file = files[0];
                load_image(file);
            }
        });

        // Paste handling
        window.addEventListener('paste', (event) => {

            console.log("paste");
            const items = event.clipboardData.items;
            console.log("items", items);

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const file = item.getAsFile();
                if (file) {
                    load_image(file);
                }
            }
        });

    </script>

    <!-- TOOLTIPS PLACEMENTS -->
    <script>
        const draw_button = document.getElementById('draw_button');
        const draw_tool_tip = document.getElementById('draw_tool_tip');
        let rect = draw_button.getBoundingClientRect();
        let offset = rect.width * .8;
        draw_tool_tip.style.top = (rect.top + offset) + 'px';
        draw_tool_tip.style.left = (rect.left + offset) + 'px';

        const move_button = document.getElementById('move_button');
        const move_tool_tip = document.getElementById('move_tool_tip');
        rect = move_button.getBoundingClientRect();
        offset = rect.width * .8;
        move_tool_tip.style.top = (rect.top + offset) + 'px';
        move_tool_tip.style.left = (rect.left + offset) + 'px';

        const erase_button = document.getElementById('erase_button');
        const erase_tool_tip = document.getElementById('erase_tool_tip');
        rect = erase_button.getBoundingClientRect();
        offset = rect.width * .8;
        erase_tool_tip.style.top = (rect.top + offset) + 'px';
        erase_tool_tip.style.left = (rect.left + offset) + 'px';

        const download_button = document.getElementById('download_button');
        const download_tool_tip = document.getElementById('download_tool_tip');
        rect = download_button.getBoundingClientRect();
        offset = rect.width * .8;
        download_tool_tip.style.top = (rect.top + offset) + 'px';
        download_tool_tip.style.left = (rect.left + offset) + 'px';

        const settings_tool_tip = document.getElementById('settings_tool_tip');
        rect = settings_button.getBoundingClientRect();
        offset = rect.width * .8;
        settings_tool_tip.style.top = (rect.top + offset) + 'px';
        settings_tool_tip.style.left = (rect.left + offset) + 'px';
    </script>

</body>
</html>